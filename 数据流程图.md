# Chat 聊天系统数据流程图

## 一、系统架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                        UI 展示层                              │
│  ChatPanel / MessageBubble / ChatInput / ApiProviderConfig  │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                     业务逻辑层                                │
│  ConversationManager / BranchManager / ConversationHistory  │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                   上下文处理层                                │
│  ContextEngine / MessageEditor / SystemPrompt / Summarizer  │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                     API 适配层                                │
│            OpenAIAdapter / GeminiAdapter                     │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                     外部 AI API                               │
│            OpenAI / Gemini / 其他兼容 API                    │
└─────────────────────────────────────────────────────────────┘
```

## 二、核心数据结构

### 2.1 消息存储结构

```
FlatMessage (扁平存储)          MessageNode (树形结构)
┌──────────────────┐            ┌──────────────────┐
│ id: string       │            │ id: string       │
│ content: string  │    构建    │ content: string  │
│ role: Role       │   ────→    │ role: Role       │
│ parentId: string │            │ parentId: string │
│ timestamp: Date  │            │ children: []     │
│ reasoning?: str  │            │ depth: number    │
└──────────────────┘            └──────────────────┘
        ↓                               ↓
   Map<id, msg>                  树形节点数组
```

### 2.2 对话树状态

```
ConversationTree
├── flatMessages: Map<string, FlatMessage>  // O(1)查找的扁平存储
├── rootNodes: MessageNode[]                 // 树形结构，用于渲染
└── activePath: string[]                     // 当前激活路径（分支路径）

示例：
用户: "你好"
  ├─ AI: "你好！很高兴认识你"  [active]
  └─ AI: "Hi! Nice to meet you" (重新生成的分支)
```

## 三、完整消息流程

### 3.1 用户发送消息流程

```
┌───────────────┐
│ 1. 用户输入   │
│  ChatPanel    │
└───────┬───────┘
        │ sendMessage(content, extraContent)
        ↓
┌───────────────────────────────────────┐
│ 2. ConversationManager                │
│  - 创建 FlatMessage (user role)        │
│  - 添加到 flatMessages Map             │
│  - 更新 activePath                     │
│  - 通知 UI 更新                        │
└───────┬───────────────────────────────┘
        │ generateAIReply()
        ↓
┌───────────────────────────────────────┐
│ 3. 构建对话历史                        │
│  - getConversationHistory(nodeId)     │
│  - 沿 parentId 链向上追溯             │
│  - 返回: FlatMessage[]                 │
└───────┬───────────────────────────────┘
        │ callAIAPI(history, config)
        ↓
┌───────────────────────────────────────┐
│ 4. API 层 (api.ts)                     │
│  - 选择适配器 (OpenAI/Gemini)         │
│  - 传递: history, config, callbacks   │
└───────┬───────────────────────────────┘
        │ adapter.callAPI()
        ↓
┌───────────────────────────────────────┐
│ 5. 上下文处理 (ContextEngine)         │
│  contextEngine.buildRequestMessages() │
│  ┌─────────────────────────────────┐ │
│  │ a. MessageEditor.from(history)  │ │
│  │ b. 应用标准处理流程：            │ │
│  │    - 插入系统提示                │ │
│  │    - 限制历史消息数               │ │
│  │    - 插入临时上下文               │ │
│  │    - 清理空消息                   │ │
│  │    - 合并相同角色消息             │ │
│  │ c. 应用自定义操作符              │ │
│  │ d. 构建最终请求消息              │ │
│  └─────────────────────────────────┘ │
└───────┬───────────────────────────────┘
        │ 返回: RequestMessage[]
        ↓
┌───────────────────────────────────────┐
│ 6. 适配器 (OpenAIAdapter/Gemini)      │
│  - 构建请求体 (model, messages...)    │
│  - 设置请求头 (API key, headers)      │
│  - 发送 HTTP 请求 (fetch)             │
└───────┬───────────────────────────────┘
        │ stream response
        ↓
┌───────────────────────────────────────┐
│ 7. 流式响应处理                        │
│  while (streaming):                   │
│    - 解析数据块                        │
│    - 提取 reasoning_content           │
│    - 提取 content                      │
│    - 调用 onThinkingUpdate()          │
│    - 调用 onAnswerUpdate()            │
└───────┬───────────────────────────────┘
        │ 完成后返回最终结果
        ↓
┌───────────────────────────────────────┐
│ 8. ConversationManager 更新           │
│  - 创建最终 AI 消息                    │
│  - 更新 flatMessages Map              │
│  - 保持 activePath 不变               │
└───────┬───────────────────────────────┘
        │
        ↓
┌───────────────────────────────────────┐
│ 9. UI 重新渲染                         │
│  - activePath 映射为 MessageNode[]    │
│  - 渲染 MessageBubble 组件            │
│  - 显示分支导航控件                    │
└───────────────────────────────────────┘
```

### 3.2 消息编辑与重新生成

```
┌─────────────────────────────────────────────┐
│ 用户编辑消息 (editUserMessage)               │
└─────────────┬───────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────────┐
│ 1. 创建新的用户消息（作为兄弟分支）           │
│    - 保持相同的 parentId                      │
│    - 生成新的 messageId                       │
│    - 更新 activePath 指向新分支               │
└─────────────┬───────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────────┐
│ 2. 触发 AI 回复生成                           │
│    - 从新消息开始构建历史                     │
│    - 执行完整的 AI 调用流程                   │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│ AI 消息重新生成 (regenerateMessage)          │
└─────────────┬───────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────────┐
│ 1. 定位到父消息（上一条用户消息）             │
│    - 获取到父消息的对话历史                   │
└─────────────┬───────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────────┐
│ 2. 创建新的 AI 消息（作为兄弟分支）           │
│    - 相同的 parentId                          │
│    - 新的 messageId                           │
│    - 添加到树中                               │
└─────────────┬───────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────────┐
│ 3. 执行 AI 生成流程                           │
│    - 使用相同的历史上下文                     │
│    - 可能产生不同的回复                       │
└─────────────────────────────────────────────┘
```

## 四、核心模块详解

### 4.1 ConversationManager (对话管理器)

**职责**：
- 管理对话状态（树结构、输入、加载状态）
- 处理用户交互（发送、编辑、重新生成）
- 协调 AI 调用和状态更新

**关键方法**：
```
- sendMessage()          发送新消息
- editUserMessage()      编辑用户消息并重新生成
- regenerateMessage()    重新生成 AI 回复
- generateAIReply()      核心 AI 调用逻辑
- updateConversationTree() 更新对话树状态
```

**状态管理**：
```
State:
  - conversationTree: ConversationTree
  - inputValue: string
  - isLoading: boolean
  - currentThinking: string  (实时思考内容)
  - currentAnswer: string    (实时回答内容)
```

### 4.2 ContextEngine (上下文引擎)

**职责**：
- 统一管理消息上下文处理
- 历史消息选择与截断
- 系统提示词汇总
- 临时上下文插入策略

**核心处理流程**：
```
buildRequestMessages(history, config, tempContent, tempPlacement)
  ↓
1. MessageEditor.from(history)
   - 将 FlatMessage[] 转换为可编辑的消息列表
  ↓
2. applyStandardPipeline()
   ├─ ensureSystemMessage()         确保有系统消息
   ├─ injectSystemPrompt()          注入系统提示词
   ├─ limitHistory()                限制历史消息数量
   ├─ addTemporaryContext()         添加临时上下文
   ├─ removeEmptyMessages()         清理空消息
   └─ mergeConsecutiveSameRole()    合并连续相同角色
  ↓
3. 应用自定义操作符
  ↓
4. editor.build() → RequestMessage[]
```

**MessageEditor API**：
```
- insertSystemMessage()     插入系统消息
- insertAfterSystem()       在系统消息后插入
- append()                  追加消息
- prepend()                 前置消息
- limit()                   限制消息数量
- removeWhere()             条件删除
- transform()               消息转换
- build()                   构建最终消息列表
```

### 4.3 BranchManager (分支管理器)

**职责**：
- 管理消息树的分支导航
- 计算分支信息（当前索引、总数、可导航方向）

**分支结构示例**：
```
用户: "介绍 Python"
  ├─ AI: "Python 是一种..."     [索引 0] ← 当前激活
  ├─ AI: "Python 是解释型..."   [索引 1]
  └─ AI: "Python 是通用..."     [索引 2]

BranchNavigation:
  currentIndex: 0
  totalBranches: 3
  canNavigateLeft: false
  canNavigateRight: true
```

### 4.4 ConversationHistory (对话历史管理)

**职责**：
- 管理多个对话会话
- 持久化存储（localStorage）
- 会话创建、加载、删除

**数据结构**：
```
ConversationMetadata:
  - id: string
  - title: string
  - timestamp: number
  - tree: ConversationTree

操作：
  - createNewConversation()    创建新对话
  - loadConversation()         加载对话
  - updateConversation()       更新对话
  - deleteConversation()       删除对话
  - clearAllConversations()    清空所有对话
```

### 4.5 适配器模式 (Adapter Pattern)

**设计思想**：
- 统一接口，屏蔽不同 AI API 的差异
- 支持 OpenAI 和 Gemini，易于扩展

**适配器接口**：
```typescript
interface ChatAdapter {
  callAPI(
    messages: FlatMessage[],
    config: AIConfig,
    abortSignal: AbortSignal,
    onThinkingUpdate: (thinking: string) => void,
    onAnswerUpdate: (answer: string) => void,
    tempContent?: string,
    tempPlacement?: 'append' | 'after_system'
  ): Promise<{ reasoning_content?: string; content: string }>
}
```

**OpenAI 适配器**：
- 标准 Chat Completions API
- 支持流式响应 (SSE)
- 支持 reasoning_content (思考过程)

**Gemini 适配器**：
- Gemini API 格式转换
- 统一为 OpenAI 格式输出

## 五、特色功能实现

### 5.1 分支对话（多轮重试）

```
原理：
- 每个消息可以有多个子消息（兄弟节点）
- activePath 记录当前激活的路径
- 用户可以在不同分支间切换

实现：
  用户消息 A
    ├─ AI 回复 1 (第一次生成)
    ├─ AI 回复 2 (重新生成)
    └─ AI 回复 3 (再次重新生成)

切换分支时：
  - 更新 activePath 指向新分支
  - 重新渲染消息列表
  - 递归选择新分支的最深路径
```

### 5.2 上下文限制与统计

```
流程：
1. 用户配置 historyLimit (如 10 条)
2. ContextEngine.getContextMetadataFromTree() 计算：
   - totalMessages: 实际消息总数
   - includedMessages: 计入上下文的消息数
   - excludedMessages: 超出限制的消息数
   - inclusionMap: 每条消息是否计入上下文

3. UI 显示上下文统计条：
   "计入 10 | 未计入 5 (历史消息共 15 条，保留上限 10)"

4. 发送请求时：
   - limitHistory() 操作符截取最近 N 条消息
   - 老消息不发送到 API，但仍保留在本地树中
```

### 5.3 临时上下文注入

```
场景：
- 用户选择了文档内容，希望 AI 基于此内容回答
- 这些内容不应永久保存在对话树中

实现：
1. additionalContent 从外部传入（如选中的文件）
2. 发送时作为 tempContent 参数传递
3. ContextEngine 根据 tempPlacement 决定位置：
   - 'append': 追加到消息列表末尾
   - 'after_system': 紧跟系统消息之后

4. 临时内容格式：
   "【参考资料】\n文件内容..."

5. 不存入 ConversationTree，下次请求时不包含
```

### 5.4 概括功能（Summarization）

```
场景：
- 对话太长，上下文即将超出限制
- 用户希望对当前讨论进行总结

流程：
┌──────────────────────────────────────┐
│ 1. 用户点击"概括"按钮                  │
└──────────────┬───────────────────────┘
               │
               ↓
┌──────────────────────────────────────┐
│ 2. buildSummarizePlan()              │
│    输入：                              │
│      - userInput (用户问题)           │
│      - conversationHistory (对话历史)  │
│      - filesText (文件内容)           │
│    输出：                              │
│      - systemPrompt (概括指令)        │
│      - userMessageContent (用户消息)   │
│      - extraContext (上下文)          │
└──────────────┬───────────────────────┘
               │
               ↓
┌──────────────────────────────────────┐
│ 3. 创建新对话会话                      │
│    - 清空当前对话树                    │
│    - 设置临时系统提示词                │
└──────────────┬───────────────────────┘
               │
               ↓
┌──────────────────────────────────────┐
│ 4. 发送概括请求                        │
│    - tempContent: 对话历史 + 文件内容  │
│    - tempPlacement: 'after_system'    │
└──────────────┬───────────────────────┘
               │
               ↓
┌──────────────────────────────────────┐
│ 5. AI 生成概括结果                     │
│    - 基于完整上下文生成概括            │
│    - 结果保存在新对话中                │
└──────────────────────────────────────┘
```

### 5.5 流式响应与实时更新

```
流式处理：
1. API 返回 Server-Sent Events (SSE) 流
2. 适配器逐块解析：
   for each chunk:
     - 提取 delta.reasoning_content
     - 提取 delta.content
     - 累加到本地变量

3. 触发回调：
   - onThinkingUpdate(thinking)  → 更新 currentThinking
   - onAnswerUpdate(answer)      → 更新 currentAnswer

4. UI 实时渲染：
   - MessageBubble 显示 currentThinking (思考过程)
   - MessageBubble 显示 currentAnswer (部分回答)
   - 打字机效果自动实现

5. 完成后：
   - 返回最终内容
   - 更新 FlatMessage
   - 清空流式状态
```

## 六、数据持久化

### 6.1 存储策略

```
localStorage 存储：
- ai_config.json                         AI 配置
- writing_conversation_history.json      对话历史元数据
- active_conversation_id.json            当前活跃对话 ID
- 每个对话的详细内容 (ConversationTree)

存储内容：
{
  conversations: [
    {
      id: "conv_123",
      title: "关于 Python 的讨论",
      timestamp: 1696234567890,
      tree: {
        flatMessages: { ... },  // Map 序列化为对象
        activePath: ["msg1", "msg2", ...]
      }
    },
    ...
  ]
}
```

### 6.2 加载与同步

```
应用启动：
1. 读取 active_conversation_id.json
2. 加载对应的对话树
3. 渲染到 UI

对话切换：
1. 保存当前对话状态
2. 加载目标对话
3. 更新 ConversationManager 状态

自动保存：
- 每次对话树更新时触发
- useEffect 监听 conversationTree 变化
- 调用 conversationHistory.updateConversation()
```

## 七、错误处理与中断

### 7.1 请求中断

```
流程：
1. 用户点击"停止生成"按钮
2. 调用 abortRequest()
3. AbortController.abort() 触发
4. fetch 请求被中断，抛出 AbortError
5. generateAIMessage() catch 块：
   - 检测到 AbortError
   - 保留已生成的部分内容
   - 创建最终消息（内容为部分生成的内容）
6. 更新对话树，显示部分结果
```

### 7.2 API 错误处理

```
常见错误：
- 网络错误 (fetch failed)
- API 错误 (401, 429, 500)
- 响应格式错误 (JSON parse error)

处理策略：
1. catch 块捕获错误
2. 提取错误信息（status code, message）
3. 创建错误消息：
   content: "生成失败: 请求超时"
4. 显示在对话中，用户可重试
```

## 八、性能优化要点

### 8.1 数据结构优化

```
为什么同时使用扁平存储和树结构？

flatMessages: Map<string, FlatMessage>
  优点：O(1) 查找、更新、删除
  用途：快速访问任意消息

rootNodes: MessageNode[]
  优点：天然的层次结构
  用途：渲染、分支导航

结合优势：
  - 扁平存储用于数据管理
  - 树结构用于 UI 渲染
  - buildTreeFromFlat() 按需转换
```

### 8.2 React 渲染优化

```
1. useCallback 缓存回调函数
   - 避免子组件不必要的重新渲染

2. 精确的状态更新
   - 只更新必要的状态字段

3. 虚拟滚动（如需要）
   - 长对话列表可使用 react-window

4. memo 优化
   - MessageBubble 可包裹在 React.memo 中
```

